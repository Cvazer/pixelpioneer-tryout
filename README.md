# Немного про реализацию.
Так как требованием стоит `Java 11+`, то я решил, что будет обидно, если я возьму 17 версию и 3 спринг бут, а он не
заведется у тех. интервьюера из-за того, что у него среда настроена под рабочий проект :D Поэтому я взял самую верхнюю
версию `Spring Boot 2` + `Java 11`, чтобы добиться максимального охвата.

В некоторых местах в коде вместо простых двух вызовов сеттеров я делаю развернутые модульные системы. Это своеобразный 
фьючер пруфинг кода. Я понимаю, что писать "наперед" - это антипаттерн, но в реальности вопрос "можно делать ту или иную 
систему легкой в расширении или нет" можно уточнить у прОдукта или у лида. В процессе подготовки тестового такой 
роскоши нет, поэтому в подобных ситуациях я считал, что ответ всегда "да, можно".

По поводу использования `var`: Я встречал много очень полярных мнений на эту тему. Сам я сторонник варов, поэтому
в реализации я их использовал почти везде. Но это не значит, что я не могу писать без них, если это принципиальный 
момент.

> Против аргумента "непонятно, какой тип должен быть" - господа, изучаем инструментарий, нажимаем `Ctrl + Q` 
и радуемся :D Также хочу напомнить, что аргумент "это же лишний клик" - это не противопоказание к перепечатыванию 
названий типов (которые в 99% случаев длиннее 3-х символов). Я боюсь даже представить, что эти великие люди будут 
делать со своими сэкономленными микросекундами <3 

# Запуск
Приложение полностью работает в докере в собственной сети в режиме `bridge`. Сервис `application` делает доступным порт
`8080`, все остальные порты не показываются. После запуска в течение примерно 30 секунд приложение становится доступным.

## Пререквизиты запуска
* Доступ в интернет для скачивания имеджей из докера
* [`Docker`](https://docs.docker.com/get-started/get-docker/) на машине
* [`Compose`](https://docs.docker.com/get-started/get-docker/) на докере

## Запуск на Docker
Для `v2` версии плагина `compose`
```bash
docker compose up -d
```

Я не проверял, работает ли мой [compose.yaml](compose.yaml) на `v1` компоузе, но по идее должен.

# Куда можно пойти и что поделать после запуска
* [`Swagger UI`](http://localhost:8080/swagger-ui/index.html) - можно посмотреть на эндпоинты и схемы.
> Важно: Аутентификация в приложении работает с использованием JWT. Если дергать эндпоинты прямо через UI сваггера, то
при нажатии кнопки `Authorize` в правом верхнем углу токен в поле вставлять с префиксом `Bearer {token}`, иначе
будет `401` код
* [`Postman`](https://www.postman.com/downloads/) - [коллекция](Pixel%20Pioneer%20-%20Tryout%20-%20Yan%20F.postman_collection.json) 
для него лежит в корне репозитория. Там уже все настроено, можно просто тыкать.

### Какие функции есть
Функции, требующие аутентификации (по пунктам можно кликать):
* [`Посмотреть текущего пользователя`](http://localhost:8080/swagger-ui/index.html#/user-controller/getUsingGET)
* [`Изменить имейлы и телефоны пользователя`](http://localhost:8080/swagger-ui/index.html#/user-controller/updateUsingPUT) -
  подробнее [тут](#изменить-имейлы-и-телефоны-пользователя)
* [`Денежный трансфер другому пользователю`](http://localhost:8080/swagger-ui/index.html#/account-controller/transferUsingPOST)

Доступно без аутентификации:
* [`Поиск по пользователям`](http://localhost:8080/swagger-ui/index.html#/user-controller/searchWithRqUsingGET) - [тут](#поиск-по-пользователям) подробнее

В автоматическом режиме работает
* [`Субсидирование баланса пользователей`](src/main/java/com/github/cvazer/tryout/pixelpioneer/service/BalanceIncrementAutomation.java) - [тут](#субсидирование-баланса-пользователей) больше

### Как правильно тыкать?
В приложении не реализована регистрация новых пользователей, но есть уже занесенные в базу.

Пользователи в формате `{логин}:{пароль}`
* `User1:password`
* `User2:password`
* `User3:password`

### Как залогиниться
На соотв. [эндпоинт](http://localhost:8080/swagger-ui/index.html#/login-controller/loginUsingPOST) стучимся данными 
пользователя. В ответ получаем закодированный в `BASE64` токен в формате `JWT` в поле `data` в ответе. Выглядеть он 
будет примерно так:

    eyJraWQiOiIyNzZkNzEzZi0yZDYzLTQ4OWQtOTg4Yi1mMWM3MzQ5MWY4NjYiLCJhbGciOiJSUzUxMiJ9.eyJzdWIiOiIxIiwianRpIjoiODMyN2RjNTAtMGQ4NC00YmFlLWI1OGUtZWNlM2JmYTQ4Mjc3In0.PcUhVZiUDtvcEjazecFM2Nq6c0dIEpgQoeT-Ezd8RKL19xV0J5N8_aKajQqW5uC3ewOMn26pkgDlyhMhTr45kKSiTGTrQO32rXrXjNNnemGgHGSnskJ3-vD-i-req8AmDPNKeuw7L7WTSax-4vqCPwAu4x2TvaAMb_djPyLyRNxWmxIBqtirpqMEmpGgmKvF5S_7mS2SxTYNsVyNATukcAzLk68sWUQsWgfqySZ9a8hSGgJyuDGu7yewkHvhYGihgEQ_996I2EOf-NwbU3kb3v8fgtjjOUKt8eeWMJR9WPZGmkB__uWkTZ9oXJKxNLJSJUzA5h6EnwMX44x31UhqMw

Его нужно поместить в хэдер `Authorization` c префиксом `Bearer` (`Bearer {token}`). Без двоеточий, знаков равно и так 
далее.
> Если использовать мою коллекцию из `Postman`, то там в запросе `Log In` уже написан скрипт, который это делает сам, 
автоматически.

### Изменить имейлы и телефоны пользователя
Я не реализовывал отдельное удаление телефона и имейла. Вместо этого я сделал универсальный эндпоинт для изменения 
пользователя, который принимает такую же DTO, что откидывает информация о пользователе. Идея в том, что ты просто 
получаешь DTO, изменяешь в ней нужные поля и закидываешь назад. Система определяет, что поменялось, и применяет.

Так, после удаления из списка, например, телефона и/или добавления нового изменения после запроса пойдут на персист. 
Система сделана модульной, чтобы можно было делать отдельные обработчики для обновления отдельных полей (наследуясь от 
[`UserDataUpdateDelegate`](src/main/java/com/github/cvazer/tryout/pixelpioneer/service/facade/userdata/update/UserDataUpdateDelegate.java)
или [`AbstractCollectionUserDataUpdateDelegate`](src/main/java/com/github/cvazer/tryout/pixelpioneer/service/facade/userdata/update/AbstractCollectionUserDataUpdateDelegate.java)).

### Поиск по пользователям
Есть небольшой нюанс: На один и тот же URL замаплено два разных метода. Разводятся они в зависимости от хэдера 
`Content-Type` в запросе. Один из них принимает `application/json` и на него можно откинуть объект типа [`SearchUserParams`](src/main/java/com/github/cvazer/tryout/pixelpioneer/api/dto/SearchUserParams.java)
, другой принимает `*/*` и работает от преданных параметров из `URL` запроса.

### Субсидирование баланса пользователей
Так я назвал увеличение баланса всех аккаунтов пользователей на 10% каждые 30 секунд. При каждом прогоне проверяется
`изначальный баланс` аккаунта в `redis`. Если там ничего нет, то `текущий` баланс считается изначальным, и 
записывается в кэш. Впоследствии это значение сравнивается с текущим балансом и размером субсидии при каждом прогоне.
Если субсидированное значение превысит `207%` от изначального баланса, то никакого субсидирования :D

> Исходя из задания мне непонятно, как предполагается, что я буду знать значение "изначального депозита". В приложении
**нет** функции депозита и логирования депозитов, где можно было бы посмотреть самый первый депозит. Да, там сказано, что 
изначальный баланс и считается "первым депозитом", но также в таблице со структурой базы **нет** поля, в котором
хранилось бы "изначальное" значение баланса, есть только "текущее". При этом **отдельно** отмечено, что без **резкой**
необходимости состав полей и таблиц менять нельзя, но критерии "резкости" не предоставлены :p

#### Зачем хранить баланс в редисе?
Раз у нас есть требование по кэшированию в `Redis` и я его в любом случае настраиваю и подключаю - почему бы не 
использовать его также и для хранения оперативной информации. 

Да, исходя из функционала в задании примерно вырисовывается некая "биржа", или типа того. В таких условиях маловероятно,
что такая информация, как "первый депозит", была бы "оперативной". Однако я принял решение делать что могу с тем, что
мне дали, и решил выйти из положения таким образом.